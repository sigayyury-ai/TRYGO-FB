import userService from './UserService';
import projectService from './ProjectService';
import projectHypothesesService from './ProjectHypothesesService';
import { checkIfProjectGenerationAllowed } from '../utils/subscription/checkIfProjectGenerationAllowed';
import { createHypothesesParts } from '../utils/hypothesis/createHypothesesParts';
import { sendEmbeddedOnboardingPasswordEmail } from '../utils/email/embeddedOnboardingEmail';
import { 
    ProjectStartType, 
    ProjectGenerationStatus,
    EmbeddedOnboardingInput as GraphQLEmbeddedOnboardingInput,
    EmbeddedOnboardingResponse as GraphQLEmbeddedOnboardingResponse
} from '../generated/graphql';
import { GenerateProjectInput } from '../utils/socketIO/generateProject';
import { sendErrorToTg } from '../utils/sendErrorToTg';

// Local interfaces for service layer (converted from GraphQL types)
export interface EmbeddedOnboardingInput {
    email: string;
    startType: ProjectStartType;
    info: string;
    url?: string;
    embedSource?: string;
}

export interface EmbeddedOnboardingResponse {
    success: boolean;
    userId?: string;
    projectId?: string;
    isNewAccount: boolean;
    passwordSent: boolean;
    errorCode?: string;
    errorMessage?: string;
    subscriptionLimitReached?: boolean;
}

class EmbeddedOnboardingService {
    /**
     * Processes embedded onboarding submission
     * Handles both new and existing users
     */
    async submitOnboarding(
        input: EmbeddedOnboardingInput
    ): Promise<EmbeddedOnboardingResponse> {
        const timestamp = new Date().toISOString();
        console.log(`[${timestamp}] [EmbeddedOnboardingService] Processing submission for email: ${input.email}`);

        try {
            // Step 1: Validate input
            this.validateInput(input);

            // Step 2: Check if email exists
            const existingUser = await userService.getUserByEmailDefault(input.email);
            let userId: string;
            let isNewAccount = false;
            let passwordSent = false;

            if (existingUser) {
                // Existing user flow
                console.log(`[${timestamp}] [EmbeddedOnboardingService] Existing user found: ${existingUser.id}`);
                userId = existingUser.id.toString();
            } else {
                // New user flow - create account with auto-generated password
                console.log(`[${timestamp}] [EmbeddedOnboardingService] Creating new account for email: ${input.email}`);
                const { user, generatedPassword } = await userService.registerWithAutoGeneratedPassword(
                    input.email
                );
                userId = user.id.toString();
                isNewAccount = true;

                // Send password email
                try {
                    await sendEmbeddedOnboardingPasswordEmail(input.email, generatedPassword);
                    passwordSent = true;
                    console.log(`[${timestamp}] [EmbeddedOnboardingService] Password email sent to: ${input.email}`);
                } catch (emailError) {
                    console.error(`[${timestamp}] [EmbeddedOnboardingService] Failed to send password email:`, emailError);
                    // Continue even if email fails - user can use password reset
                }
            }

            // Step 3: Check subscription limits
            console.log(`[${timestamp}] [EmbeddedOnboardingService] Checking subscription limits for userId: ${userId}`);
            const limitCheck = await checkIfProjectGenerationAllowed(userId);
            
            if (!limitCheck.allowed) {
                console.log(`[${timestamp}] [EmbeddedOnboardingService] Subscription limit reached for userId: ${userId}`);
                return {
                    success: false,
                    userId,
                    isNewAccount,
                    passwordSent,
                    errorCode: 'SUBSCRIPTION_LIMIT_REACHED',
                    errorMessage: limitCheck.errorMessage || 'You have reached the maximum number of projects allowed for this subscription',
                    subscriptionLimitReached: true,
                };
            }

            // Step 4: Create project
            console.log(`[${timestamp}] [EmbeddedOnboardingService] Creating project for userId: ${userId}`);
            const projectInput: GenerateProjectInput = {
                startType: input.startType,
                info: input.info,
                url: input.url,
            };

            const projectResult = await projectService.createProject(projectInput, userId);
            
            if (projectResult.isError || !projectResult.project) {
                console.error(`[${timestamp}] [EmbeddedOnboardingService] Failed to create project:`, projectResult.errorMessage);
                return {
                    success: false,
                    userId,
                    isNewAccount,
                    passwordSent,
                    errorCode: 'PROJECT_CREATION_FAILED',
                    errorMessage: projectResult.errorMessage || 'Failed to create project',
                };
            }

            const project = projectResult.project;
            const projectId = project._id.toString();
            console.log(`[${timestamp}] [EmbeddedOnboardingService] Project created: ${projectId}`);

            // Step 5: Trigger project generation (programmatically, without socket)
            console.log(`[${timestamp}] [EmbeddedOnboardingService] Starting project generation for projectId: ${projectId}`);
            try {
                await this.generateProjectProgrammatically(projectId, userId);
                console.log(`[${timestamp}] [EmbeddedOnboardingService] SUCCESS: Onboarding completed for userId: ${userId}, projectId: ${projectId}`);
            } catch (generationError) {
                // Project is created but generation failed - still return success but log error
                console.error(`[${timestamp}] [EmbeddedOnboardingService] Project created but generation failed:`, generationError);
                // Continue - project is created, user can access it even if generation is incomplete
            }

            return {
                success: true,
                userId,
                projectId,
                isNewAccount,
                passwordSent,
            };
        } catch (error) {
            const errorTimestamp = new Date().toISOString();
            console.error(`[${errorTimestamp}] [EmbeddedOnboardingService] ERROR:`, error);
            
            // Send error to Telegram if configured
            if (error instanceof Error) {
                sendErrorToTg(error);
            }

            return {
                success: false,
                isNewAccount: false,
                passwordSent: false,
                errorCode: 'INTERNAL_ERROR',
                errorMessage: error instanceof Error ? error.message : 'An unexpected error occurred',
            };
        }
    }

    /**
     * Generates project programmatically (without socket)
     * Adapted from generateProject socket handler
     */
    private async generateProjectProgrammatically(
        projectId: string,
        userId: string
    ): Promise<void> {
        const timestamp = new Date().toISOString();
        console.log(`[${timestamp}] [EmbeddedOnboardingService.generateProjectProgrammatically] Starting for projectId: ${projectId}`);

        try {
            // Mark project generation as started
            await userService.changeUser(userId, {
                isProjectGenerationStarted: true,
            });

            // Get project
            const project = await projectService.getProjectById(projectId, userId);
            const isFirstProject = await projectService.checkIfFirstProject(userId);

            // Generate project hypotheses
            console.log(`[${timestamp}] [EmbeddedOnboardingService.generateProjectProgrammatically] Creating hypotheses...`);
            const responseProjectHypotheses = await projectHypothesesService.createProjectHypotheses(
                project.assistantId,
                projectId,
                userId,
                isFirstProject
            );

            if (responseProjectHypotheses.isError || !responseProjectHypotheses.hypotheses) {
                throw new Error(responseProjectHypotheses.errorMessage || 'Failed to create project hypotheses');
            }

            console.log(`[${timestamp}] [EmbeddedOnboardingService.generateProjectProgrammatically] Hypotheses created: ${responseProjectHypotheses.hypotheses.length}`);

            // Create hypotheses parts
            console.log(`[${timestamp}] [EmbeddedOnboardingService.generateProjectProgrammatically] Creating hypotheses parts...`);
            const responseCreateHypothesesParts = await createHypothesesParts({
                projectHypotheses: responseProjectHypotheses.hypotheses,
                assistantId: project.assistantId,
                userId,
            });

            if (responseCreateHypothesesParts.isError) {
                throw new Error(responseCreateHypothesesParts.errorMessage || 'Failed to create hypotheses parts');
            }

            // Update project status
            project.generationStatus = ProjectGenerationStatus.Generated;
            await project.save();
            await userService.changeUser(userId, {
                isProjectGenerated: true,
            });

            console.log(`[${timestamp}] [EmbeddedOnboardingService.generateProjectProgrammatically] SUCCESS: Project generation completed`);
        } catch (error) {
            const errorTimestamp = new Date().toISOString();
            console.error(`[${errorTimestamp}] [EmbeddedOnboardingService.generateProjectProgrammatically] ERROR:`, error);
            throw error;
        }
    }

    /**
     * Validates embedded onboarding input
     */
    private validateInput(input: EmbeddedOnboardingInput): void {
        // Email validation (basic format check - detailed validation happens in UserService)
        if (!input.email || !input.email.includes('@')) {
            throw new Error('Invalid email format');
        }

        // Description validation
        if (!input.info || input.info.trim().length < 10) {
            throw new Error('Project description must be at least 10 characters');
        }

        // URL validation (if startType is URL_IMPORT)
        if (input.startType === ProjectStartType.UrlImport) {
            if (!input.url || input.url.trim().length === 0) {
                throw new Error('URL is required when importing from website');
            }
            const urlPattern = /^https?:\/\/.+\..+/i;
            if (!urlPattern.test(input.url)) {
                throw new Error('URL must be in format https://example.com');
            }
        }
    }
}

const embeddedOnboardingService = new EmbeddedOnboardingService();
export default embeddedOnboardingService;
